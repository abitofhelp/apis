load("@rules_proto//proto:defs.bzl", "proto_library")
load("@rules_proto_grpc_grpc_gateway//:defs.bzl", "gateway_grpc_library")

# rules_proto (-> proto descriptor set):
#  Building a proto_library creates a file named xxxxx-descriptor-set.proto.bin,
#  which is the descriptor set's binary file.  One use case for the descriptor
#  set is generating code without having to parse .proto files.
proto_library(
    name = "access_tier_proto",
    srcs = ["access_tier.proto"],
    visibility = ["//visibility:public"],
    deps = ["@com_google_protobuf//:timestamp_proto"],
)

# rules_proto_grpc (-> proto descriptor set, pb files, grpc files, grpc-gateway files):
# This rule takes a proto descriptor set, generated by proto_library rule, and produces the following files:
# .a (static library):  It is an archive of object files that can be linked with other object file to form an executable
#                       or shared library.  Use 'go tool objdump' for disassembly and 'go tool nm' for listing symbols.
# .o (object file):     It contains machine code and data for a single compilation unit.  Use 'go tool objdump' for
#                       disassembly and 'go tool nm' for listing symbols.
# .x (symbol file):     It contain information about the symbols defined by a go_library (not the implementation) as well
#                       as static analysis information collected by nogo (if you use it),
# .pb.go (protoBuf):    It contains generated ProtoBuf Go code.
# .pb.gw.go (gateway):  It contains generated HTTP proxy server Go code.
# _grpc.pb.go (grpc):   It contains generated gRPC Go server and client stubs.
gateway_grpc_library(
    name = "access_tier",
    importpath = "github.com/abitofhelp/apis/proto/enum/access_tier/v5",
    protos = ["access_tier_proto"],
    visibility = ["//visibility:public"],
)

alias(
    name = "go_default_library",
    actual = ":access_tier",
    visibility = ["//visibility:public"],
)
